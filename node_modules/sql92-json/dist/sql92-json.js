require=(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
function couldNotParseSelectField (field) {
  var message = 'Could not parse select field'
  if (field) message = message + ' ' + JSON.stringify(field)

  var error = new TypeError(message)
  error.field = field

  return error
}

exports.couldNotParseSelectField

function functionRequired (functionName) {
  var message = 'Function required'
  if (functionName) message += ': ' + functionName

  var error = new Error(message)
  error.functionName = functionName

  return error
}

exports.functionRequired

function invalidAlias (alias) {
  var message = 'Invalid alias'
  if (alias) message += ': ' + JSON.stringify(alias)

  var error = new Error(message)
  error.alias = alias

  return error
}

exports.invalidAlias

function invalidDataType (dataType) {
  var message = 'Invalid data type'
  if (dataType) message += ': ' + dataType

  var error = new Error(message)
  error.dataType = dataType

  return error
}

exports.invalidDataType

function invalidInterval (left, right) {
  var message = 'invalid interval'
  if (left || right) message += ':'
  if (left) message += ' ' + left
  if (right) message += ' ' + right

  var error = new Error(message)
  error.left = left
  error.right = right

  return error
}

exports.invalidInterval

function invalidJSONData (data) {
  var message = 'Invalid JSON data'
  if (data) message += ': ' + JSON.stringify(data)

  var error = new Error(message)
  error.data = data

  return error
}

exports.invalidJSONData

function invalidSQL (sql) {
  var message = 'Invalid SQL'
  if (sql) message += ': ' + sql

  var error = new Error(message)
  error.sql = sql

  return error
}

exports.invalidSQL

function invalidTableName (tableName) {
  var message = 'Invalid table name'
  if (tableName) message += ': ' + tableName

  var error = new Error(message)
  error.tableName = tableName

  return error
}

exports.invalidTableName

function unclosedParenthesisExpression (tokens) {
  var message = 'Unclosed parenthesis'

  var error = new Error(message)
  error.tokens = tokens

  return error
}

exports.unclosedParenthesisExpression

},{}],2:[function(require,module,exports){
var error = require('../error')

var isLogicalOperator = require('../util/isLogicalOperator')
var isKeywordOrOperator = require('../util/isKeywordOrOperator')
var isStringNumber = require('../util/isStringNumber')

var isAnd = isLogicalOperator('AND')

function between (item, left, and, right, not) {
  var json = []
  var interval = {}

  if (not) interval['NOT BETWEEN'] = []
  else interval.BETWEEN = []

  if (!isAnd(and)) throw error.invalidSQL()

  if (isKeywordOrOperator(left) || isKeywordOrOperator(right)) {
    throw error.invalidInterval(left, right)
  }

  if (isStringNumber(left)) {
    left = parseFloat(left)
  }

  if (isStringNumber(right)) {
    right = parseFloat(right)
  }

  if (not) interval['NOT BETWEEN'].push(left, right)
  else interval.BETWEEN.push(left, right)

  json.push(item)
  json.push(interval)

  return json
}

module.exports = between

},{"../error":1,"../util/isKeywordOrOperator":67,"../util/isLogicalOperator":68,"../util/isStringNumber":78}],3:[function(require,module,exports){
var extractMathExpression = require('../util/extractMathExpression')
var isComparisonOperator = require('../util/isComparisonOperator')
var isMathOperator = require('../util/isMathOperator')
var isStringNumber = require('../util/isStringNumber')

function comparison (tokens) {
  var condition = {}
  var leftOperand
  var operator
  var operatorIndex
  var rightOperand
  var token

  // Look for first operator.
  for (var i = 0; i < tokens.length; i++) {
    token = tokens[i]

    if (isComparisonOperator(token)) {
      operator = token
      operatorIndex = i
      break
    }
  }

  // TODO check if operator was found, otherwise raise an error.
  // TODO check also operatorIndex, should be greater than 0.

  // TODO extract math expressions on left side.
  // probably it would be necessary to use the same logic of right
  // math expression but reversing the tone array.
  // Maybe it needs also to change JSON syntax.
  leftOperand = tokens[operatorIndex - 1]

  if (isStringNumber(leftOperand)) {
    leftOperand = parseFloat(leftOperand)
  }

  if (isMathOperator(tokens[operatorIndex + 2])) {
    rightOperand = extractMathExpression(tokens.slice(operatorIndex + 1))

    // Convert number from strings.
    rightOperand = rightOperand.map(function (element) {
      if (isStringNumber(element)) return parseFloat(element)
      else return element
    })
  } else {
    rightOperand = tokens[operatorIndex + 1]

    if (isStringNumber(rightOperand)) {
      rightOperand = parseFloat(rightOperand)
    }
  }

  condition[operator] = rightOperand

  return [leftOperand, condition]
}

module.exports = comparison

},{"../util/extractMathExpression":59,"../util/isComparisonOperator":62,"../util/isMathOperator":69,"../util/isStringNumber":78}],4:[function(require,module,exports){
var error = require('../error')

var between = require('./between')
var comparison = require('./comparison')
var isAnyJoin = require('../util/isAnyJoin')
var isComparisonOperator = require('../util/isComparisonOperator')
var isKeywordOrOperator = require('../util/isKeywordOrOperator')
var isKeyword = require('../util/isKeyword')
var isLogicalOperator = require('../util/isLogicalOperator')
var isSingleQuotedString = require('../util/isSingleQuotedString')
var isStringNumber = require('../util/isStringNumber')
var like = require('./like')
var removeFirstAndLastChar = require('../util/removeFirstAndLastChar')

var isAnd = isLogicalOperator('AND')
var isOr = isLogicalOperator('OR')

var isBetween = isKeyword('BETWEEN')
var isIn = isKeyword('IN')
var isLike = isKeyword('LIKE')
var isNotBetween = isKeyword('NOT BETWEEN')
var isNotLike = isKeyword('NOT LIKE')
var isSelect = isKeyword('SELECT')

/**
 * Parse a filter condition, like a JOIN, WHERE or HAVING clause.
 *
 * @param {Array} tokens
 * @param {Number} startIndex
 * @param {String} sql
 *
 * @returns {Array} json
 */

function condition (tokens, startIndex, select, sql) {
  var json = []
  var numTokens = tokens.length

  var afterNextToken
  var currentToken
  var foundRightParenthesis = false
  var nextToken
  var token

  var andCondition = null
  var comparisonExpression
  var currentCondition = null
  var orCondition = null

  var leftOperand
  var rightOperand

  var j
  var not

  for (var i = startIndex; i < numTokens; i++) {
    token = tokens[i]
    nextToken = tokens[i + 1]
    afterNextToken = tokens[i + 2]
    var numOpenParenthesis

    // Stop if some join is found.
    if (isAnyJoin(token)) break

    if (isAnd(token)) andCondition = { AND: [] }
    if (isOr(token)) orCondition = { OR: [] }

    // Iterate over sub conditions.

    if ((!isIn(token)) && (nextToken === '(')) {
      foundRightParenthesis = false
      numOpenParenthesis = 1
      var subConditionTokens = []

      for (j = i + 2; j < numTokens; j++) {
        if (foundRightParenthesis) continue

        token = tokens[j]

        if (token === '(') numOpenParenthesis++
        if (token === ')') numOpenParenthesis--

        if (numOpenParenthesis === 0) {
          foundRightParenthesis = true
          i = j + 1
        } else {
          subConditionTokens.push(token)
        }
      }

      if (!foundRightParenthesis) throw error.unclosedParenthesisExpression(tokens)

      var logicalExpression = condition(subConditionTokens, 0, select, sql)

      if (andCondition) {
        andCondition.AND = logicalExpression
        json = json.concat(andCondition)
        andCondition = null
      } else if (orCondition) {
        orCondition.OR = logicalExpression
        json = json.concat(orCondition)
        orCondition = null
      } else {
        json = json.concat(logicalExpression)
      }
    }

    // Common condition can be OR, AND, BETWEEN, NOT BETWEEN, LIKE, NOT LIKE.

    if (isBetween(nextToken) || isNotBetween(nextToken)) {
      try {
        if (isNotBetween(nextToken)) not = true

        comparisonExpression = between(token, tokens[i + 2], tokens[i + 3], tokens[i + 4], not)

        if (andCondition) {
          andCondition.AND = comparisonExpression
          json = json.concat(andCondition)
          andCondition = null
        } else if (orCondition) {
          orCondition.OR = comparisonExpression
          json = json.concat(orCondition)
          orCondition = null
        } else {
          json = json.concat(comparisonExpression)
        }

        i = i + 4
      } catch (err) { throw err }
    }

    if (isLike(nextToken) || isNotLike(nextToken)) {
      try {
        comparisonExpression = like(token, nextToken, afterNextToken)

        if (andCondition) {
          andCondition.AND = comparisonExpression
          json = json.concat(andCondition)
          andCondition = null
        } else if (orCondition) {
          orCondition.OR = comparisonExpression
          json = json.concat(orCondition)
          orCondition = null
        } else {
          json = json.concat(comparisonExpression)
        }

        i = i + 2
      } catch (err) { throw err }
    }

    if (isComparisonOperator(nextToken)) {
      try {
        comparisonExpression = comparison(tokens.slice(i))

        if (andCondition) {
          andCondition.AND = andCondition.AND.concat(comparisonExpression)
          json = json.concat(andCondition)
          andCondition = null
        } else if (orCondition) {
          orCondition.OR = orCondition.OR.concat(comparisonExpression)

          json = json.concat(orCondition)

          orCondition = null
        } else {
          json = json.concat(comparisonExpression)
        }

        i = i + 1
      } catch (err) { throw err }
    }

    // TODO There is another isIn conditions in this file and both can be merged.
    if (isIn(token)) {
      leftOperand = tokens[i - 1]
      nextToken = tokens[i + 1]
      foundRightParenthesis = false

      if (nextToken !== '(') throw error.invalidSQL(sql)

      if (!afterNextToken) throw error.invalidSQL(sql)

      if (isSelect(afterNextToken)) {
        currentCondition = {}
        var subQueryTokens = []

        for (j = i + 2; j < numTokens; j++) {
          token = tokens[j]

          if (token === ')') {
            currentCondition.IN = select(subQueryTokens, sql)
            json.push(leftOperand, currentCondition)

            foundRightParenthesis = true
            i = j
          } else {
            subQueryTokens.push(token)
          }
        }

        if (foundRightParenthesis) {
          foundRightParenthesis = false
        } else {
          throw error.invalidSQL(sql)
        }
      } else {
        if (!currentCondition) currentCondition = {}
        rightOperand = []

        if (isKeywordOrOperator(leftOperand)) throw error.invalidSQL(sql)
        if (isStringNumber(leftOperand)) throw error.invalidSQL(sql)

        for (j = i + 2; j < numTokens; j = j + 2) {
          currentToken = tokens[j]
          nextToken = tokens[j + 1]

          if ((nextToken === ',') || (nextToken === ')')) {
            if (isSingleQuotedString(currentToken)) {
              rightOperand.push(removeFirstAndLastChar(currentToken))
            }

            if (isStringNumber(currentToken)) {
              rightOperand.push(parseFloat(currentToken))
            }

            // TODO I am not sure if there are other cases,
            // should I raise an exception here, if token is not
            // a string or is not a number?
          }

          // Clean up, this will be the last iteration so place
          // the cursor at the right position and remember that
          // we found a right parenthesis.

          if (nextToken === ')') {
            i = j + 1

            foundRightParenthesis = true

            break
          }
        }

        if (!foundRightParenthesis) throw error.invalidSQL(sql)

        currentCondition[token] = rightOperand

        if (andCondition) {
          andCondition.AND.push(leftOperand, currentCondition)
          json.push(andCondition)
          andCondition = null
          currentCondition = null
          continue
        }

        if (orCondition) {
          orCondition.OR.push(leftOperand, currentCondition)
          json.push(orCondition)
          orCondition = null
          currentCondition = null
          continue
        }

        json.push(leftOperand, currentCondition)
        currentCondition = null
      }
    }
  }

  return json
}

module.exports = condition

},{"../error":1,"../util/isAnyJoin":60,"../util/isComparisonOperator":62,"../util/isKeyword":66,"../util/isKeywordOrOperator":67,"../util/isLogicalOperator":68,"../util/isSingleQuotedString":75,"../util/isStringNumber":78,"../util/removeFirstAndLastChar":88,"./between":2,"./comparison":3,"./like":10}],5:[function(require,module,exports){
var error = require('../error')

var isKeyword = require('../util/isKeyword')
var isTableName = require('../util/isTableName')
var select = require('./select')

var isAs = isKeyword('AS')
var isCreateTable = isKeyword('CREATE TABLE')

/**
 * Parse and serialize a CREATE TABLE statement.
 *
 * @params {Array} tokens
 * @params {Array} [sql] used to raise errors, if any
 *
 * @returns {Object} json that serialize the SQL statement.
 */

function createTable (tokens, sql) {
  var json = {}

  var firstToken = tokens[0]
  var tableName = tokens[1]

  if (!isCreateTable(firstToken)) throw error.invalidSQL(sql)

  if (!isTableName(tableName)) throw error.invalidTableName(tableName)

  json.name = tableName

  if (isAs(tokens[2])) {
    json.AS = select(tokens.slice(3))
  } else {
    json.fields = []

    for (var i = 2; i < tokens.length; i++) {
      var token = tokens[i]
      var nextToken = tokens[i + 1]

      if (token === '(') continue
      if (token === ',') continue
      if (token === ')') continue

      json.fields.push([token, nextToken])
      i++
    }
  }

  return { 'CREATE TABLE': json }
}

module.exports = createTable

},{"../error":1,"../util/isKeyword":66,"../util/isTableName":81,"./select":11}],6:[function(require,module,exports){
var error = require('../error')

var condition = require('./condition')
var select = require('./select')

var isKeyword = require('../util/isKeyword')
var isTableName = require('../util/isTableName')

var isDeleteFrom = isKeyword('DELETE FROM')

/**
 * Parse and serialize a DELETE FROM statement.
 *
 * @params {Array} tokens
 * @params {Array} [sql] used to raise errors, if any
 *
 * @returns {Object} json that serialize the SQL statement.
 */

function deleteFrom (tokens, sql) {
  var firstToken = tokens[0]
  var tableName = tokens[1]
  var json = {}

  if (!isDeleteFrom(firstToken)) throw error.invalidSQL(sql)

  if (!isTableName(tableName)) throw error.invalidTableName(tableName)

  json['DELETE FROM'] = tableName

  if (tokens.length > 2) {
    json.WHERE = condition(tokens.splice(0), 2, select, sql)
  }

  return json
}

module.exports = deleteFrom

},{"../error":1,"../util/isKeyword":66,"../util/isTableName":81,"./condition":4,"./select":11}],7:[function(require,module,exports){
var error = require('../error')

var isKeyword = require('../util/isKeyword')
var isTableName = require('../util/isTableName')

var isDropTable = isKeyword('DROP TABLE')

/**
 * Parse and serialize a DROP TABLE statement.
 *
 * @params {Array} tokens
 * @params {Array} [sql] used to raise errors, if any
 *
 * @returns {Object} json that serialize the SQL statement.
 */

function dropTable (tokens, sql) {
  var firstToken = tokens[0]
  var tableName = tokens[1]

  if (!isDropTable(firstToken)) throw error.invalidSQL(sql)

  if (!isTableName(tableName)) throw error.invalidTableName(tableName)

  return { 'DROP TABLE': tableName }
}

module.exports = dropTable

},{"../error":1,"../util/isKeyword":66,"../util/isTableName":81}],8:[function(require,module,exports){
var error = require('../error')

var isKeyword = require('../util/isKeyword')
var tokenize = require('../util/tokenize')

var createTable = require('./createTable')
var deleteFrom = require('./deleteFrom')
var dropTable = require('./dropTable')
var select = require('./select')

var isCreateTable = isKeyword('CREATE TABLE')
var isDeleteFrom = isKeyword('DELETE FROM')
var isDropTable = isKeyword('DROP TABLE')
var isInsert = isKeyword('INSERT')
var isSelect = isKeyword('SELECT')
var isTruncate = isKeyword('TRUNCATE')
var isUpdate = isKeyword('UPDATE')

/**
 * Convert SQL to JSON.
 *
 * @param {String} sql
 *
 * @returns {Object} json
 */

function parse (sql) {
  var json
  var tokens = tokenize(sql)

  var firstToken = tokens[0]

  function serialize (json, tokens) {
    var firstTokenIsValid = (
      isCreateTable(firstToken) ||
      isDeleteFrom(firstToken) ||
      isDropTable(firstToken) ||
      isInsert(firstToken) ||
      isSelect(firstToken) ||
      isTruncate(firstToken) ||
      isUpdate(firstToken)
    )

    if (!firstTokenIsValid) throw error.invalidSQL(sql)

    if (isCreateTable(firstToken)) return createTable(tokens, sql)
    if (isDeleteFrom(firstToken)) return deleteFrom(tokens, sql)
    if (isDropTable(firstToken)) return dropTable(tokens, sql)
    if (isSelect(firstToken)) return select(tokens, sql)
  }

  if (tokens.indexOf(';') === -1) {
    json = {}

    return serialize(json, tokens)
  } else {
    json = []

    // TODO consider ';' as a sql statements separator
    // loop over tokens and create an array of queries
    return json
  }
}

module.exports = parse

},{"../error":1,"../util/isKeyword":66,"../util/tokenize":92,"./createTable":5,"./deleteFrom":6,"./dropTable":7,"./select":11}],9:[function(require,module,exports){
var condition = require('./condition')

var isAnyJoin = require('../util/isAnyJoin')
var countTokens = require('../util/countTokens')
var isKeyword = require('../util/isKeyword')
var isTableName = require('../util/isTableName')

var isOn = isKeyword('ON')

function join (tokens, startIndex, select, sql) {
  var numTokens = tokens.length
  var joinExpression = {}
  var foundTable = false

  for (var j = startIndex; j < numTokens; j++) {
    var token = tokens[j]
    var nextToken = tokens[j + 1]

    if (isAnyJoin(token)) {
      joinExpression[token] = join(tokens, j + 1, select, sql)
      break
    }

    if (foundTable) {
      if (isOn(token)) {
        joinExpression.ON = condition(tokens, j, select, sql)
        j += countTokens(joinExpression.ON)
        continue
      }
    } else {
      if (isTableName(token)) {
        foundTable = true
        joinExpression[nextToken] = token
        j++
      }
    }
  }

  return joinExpression
}

module.exports = join

},{"../util/countTokens":55,"../util/isAnyJoin":60,"../util/isKeyword":66,"../util/isTableName":81,"./condition":4}],10:[function(require,module,exports){
function like (item, operator, string) {
  var comparison = {}

  comparison[operator] = string

  return [item, comparison]
}

module.exports = like

},{}],11:[function(require,module,exports){
var error = require('../error')

var countTokens = require('../util/countTokens')
var isAnyJoin = require('../util/isAnyJoin')
var isDoubleQuotedString = require('../util/isDoubleQuotedString')
var isKeyword = require('../util/isKeyword')
var isMathOperator = require('../util/isMathOperator')
var isSetOperator = require('../util/isSetOperator')
var isStar = require('../util/isStar')
var isString = require('../util/isString')
var isStringNumber = require('../util/isStringNumber')
var isStringOperator = require('../util/isStringOperator')
var isTableName = require('../util/isTableName')
var removeFirstAndLastChar = require('../util/removeFirstAndLastChar')
var tokensEnclosedByParenthesis = require('../util/tokensEnclosedByParenthesis')

var isAs = isKeyword('AS')
var isAsc = isKeyword('ASC')
var isAvg = isKeyword('AVG')
var isCount = isKeyword('COUNT')
var isDesc = isKeyword('DESC')
var isDistinct = isKeyword('DISTINCT')
var isFrom = isKeyword('FROM')
var isGroupBy = isKeyword('GROUP BY')
var isHaving = isKeyword('HAVING')
var isLimit = isKeyword('LIMIT')
var isLower = isKeyword('LOWER')
var isMax = isKeyword('MAX')
var isMin = isKeyword('MIN')
var isNvl = isKeyword('NVL')
var isOffset = isKeyword('OFFSET')
var isOrderBy = isKeyword('ORDER BY')
var isSelect = isKeyword('SELECT')
var isSum = isKeyword('SUM')
var isUpper = isKeyword('UPPER')
var isWhere = isKeyword('WHERE')

var condition = require('./condition')
var join = require('./join')

/**
 * Parse and serialize a SELECT statement.
 *
 * @params {Array} tokens
 * @params {Array} [sql] used to raise errors, if any
 *
 * @returns {Object} json that serialize the SQL statement.
 */

function select (tokens, sql) {
  var json = { SELECT: [] }

  var aliasExpression
  var avgExpression
  var countExpression
  var joinKeyword
  var lowerExpression
  var maxExpression
  var minExpression
  var nvlExpression
  var subQueryExpression
  var sumExpression
  var upperExpression

  var table
  var setOperator

  var afterNextToken
  var firstToken = tokens[0]
  var nextToken
  var nextTokenIsNotKeyword
  var nextTokenIsAlias
  var numTokens = tokens.length
  var subQueryTokens
  var token

  var i

  var foundFrom = false
  var foundLimit = false
  var foundGroupBy = false
  var foundHaving = false
  var foundOffset = false
  var foundOrderBy = false
  var foundSetOperator = false
  var foundWhere = false

  var fromIndex
  var groupByIndex
  var havingIndex
  var limitIndex
  var offsetIndex
  var orderByIndex
  var setOperatorIndex
  var whereIndex

  if (!isSelect(firstToken)) throw error.invalidSQL(sql)

  // SELECT
  // ////////////////////////////////////////////////////////////////////////

  for (i = 1; i < numTokens; i++) {
    token = tokens[i]
    nextToken = tokens[i + 1]
    afterNextToken = tokens[i + 2]

    if (isFrom(token)) {
      foundFrom = true
      fromIndex = i
      break
    }

    // A query could use a set operator without a FROM clause, for example
    //
    // SELECT 1
    // UNION
    // SELECT num FROM mytable

    if (isSetOperator(token)) {
      foundSetOperator = true
      setOperator = token
      setOperatorIndex = i
      break
    }

    if (token === ',') continue

    if (isDistinct(token)) {
      json.DISTINCT = true
      continue
    }

    // Check for aliases first, since it is found looking at next token.

    if (isAs(nextToken)) {
      aliasExpression = { AS: {} }

      if (!isString(afterNextToken)) throw error.invalidSQL(sql)

      if (isDoubleQuotedString(afterNextToken)) {
        afterNextToken = removeFirstAndLastChar(afterNextToken)
      }

      // TODO a math expression could have an alias?
      // SELECT 1 + 2 AS sum

      if (isStringNumber(token)) token = parseFloat(token)

      aliasExpression.AS[afterNextToken] = token

      json.SELECT.push(aliasExpression)

      i += 2

      continue
    }

    // Math expressions.

    if (isMathOperator(nextToken)) {
      // TODO for loop to get more complex math expressions
      json.SELECT.push([parseFloat(token), nextToken, parseFloat(afterNextToken)])
      i = i + 2
      continue
    }

    if (isStringNumber(token)) {
      json.SELECT.push(parseFloat(token))

      continue
    }

    if (isAvg(token)) {
      avgExpression = {}

      tokensEnclosedByParenthesis(tokens, i + 1).forEach(function (token) {
        i++

        if (['(', ',', ')'].indexOf(token) > -1) return

        if (isStringNumber(token)) {
          avgExpression.AVG = parseFloat(token)
        } else {
          avgExpression.AVG = token
        }
      })

      nextToken = tokens[i + 1]
      afterNextToken = tokens[i + 2]

      if (isAs(nextToken)) {
        if (isDoubleQuotedString(afterNextToken)) {
          afterNextToken = removeFirstAndLastChar(afterNextToken)
        }

        avgExpression.AS = afterNextToken
        i = i + 2
      }

      json.SELECT.push(avgExpression)

      continue
    }

    if (isCount(token)) {
      countExpression = {}

      tokensEnclosedByParenthesis(tokens, i + 1).forEach(function (token) {
        i++

        if (['(', ',', ')'].indexOf(token) > -1) return

        if (isDistinct(token)) {
          countExpression.DISTINCT = true
          return
        }

        if (isStringNumber(token)) {
          countExpression.COUNT = parseFloat(token)
        } else {
          countExpression.COUNT = token
        }
      })

      nextToken = tokens[i + 1]
      afterNextToken = tokens[i + 2]

      if (isAs(nextToken)) {
        if (isDoubleQuotedString(afterNextToken)) {
          afterNextToken = removeFirstAndLastChar(afterNextToken)
        }

        countExpression.AS = afterNextToken
        i = i + 2
      }

      json.SELECT.push(countExpression)

      continue
    }

    if (isLower(token)) {
      lowerExpression = {}

      tokensEnclosedByParenthesis(tokens, i + 1).forEach(function (token) {
        i++

        if (['(', ',', ')'].indexOf(token) > -1) return

        if (isStringNumber(token)) {
          lowerExpression.LOWER = parseFloat(token)
        } else {
          lowerExpression.LOWER = token
        }
      })

      nextToken = tokens[i + 1]
      afterNextToken = tokens[i + 2]

      if (isAs(nextToken)) {
        if (isDoubleQuotedString(afterNextToken)) {
          afterNextToken = removeFirstAndLastChar(afterNextToken)
        }

        lowerExpression.AS = afterNextToken
        i = i + 2
      }

      json.SELECT.push(lowerExpression)

      continue
    }

    if (isMax(token)) {
      maxExpression = {}

      tokensEnclosedByParenthesis(tokens, i + 1).forEach(function (token) {
        i++

        if (['(', ',', ')'].indexOf(token) > -1) return

        if (isStringNumber(token)) {
          maxExpression.MAX = parseFloat(token)
        } else {
          maxExpression.MAX = token
        }
      })

      nextToken = tokens[i + 1]
      afterNextToken = tokens[i + 2]

      if (isAs(nextToken)) {
        if (isDoubleQuotedString(afterNextToken)) {
          afterNextToken = removeFirstAndLastChar(afterNextToken)
        }

        maxExpression.AS = afterNextToken
        i = i + 2
      }

      json.SELECT.push(maxExpression)

      continue
    }

    if (isMin(token)) {
      minExpression = {}

      tokensEnclosedByParenthesis(tokens, i + 1).forEach(function (token) {
        i++

        if (['(', ',', ')'].indexOf(token) > -1) return

        if (isStringNumber(token)) {
          minExpression.MIN = parseFloat(token)
        } else {
          minExpression.MIN = token
        }
      })

      nextToken = tokens[i + 1]
      afterNextToken = tokens[i + 2]

      if (isAs(nextToken)) {
        if (isDoubleQuotedString(afterNextToken)) {
          afterNextToken = removeFirstAndLastChar(afterNextToken)
        }

        minExpression.AS = afterNextToken
        i = i + 2
      }

      json.SELECT.push(minExpression)

      continue
    }

    if (isNvl(token)) {
      nvlExpression = { NVL: [] }

      tokensEnclosedByParenthesis(tokens, i + 1).forEach(function (token) {
        i++

        if (['(', ',', ')'].indexOf(token) > -1) return

        if (isStringNumber(token)) {
          nvlExpression.NVL.push(parseFloat(token))
        } else {
          nvlExpression.NVL.push(token)
        }
      })

      nextToken = tokens[i + 1]
      afterNextToken = tokens[i + 2]

      if (isAs(nextToken)) {
        if (isDoubleQuotedString(afterNextToken)) {
          afterNextToken = removeFirstAndLastChar(afterNextToken)
        }

        nvlExpression.AS = afterNextToken
        i = i + 2
      }

      json.SELECT.push(nvlExpression)

      continue
    }

    if (isSum(token)) {
      sumExpression = {}

      tokensEnclosedByParenthesis(tokens, i + 1).forEach(function (token) {
        i++

        if (['(', ',', ')'].indexOf(token) > -1) return

        if (isStringNumber(token)) {
          sumExpression.SUM = parseFloat(token)
        } else {
          sumExpression.SUM = token
        }
      })

      nextToken = tokens[i + 1]
      afterNextToken = tokens[i + 2]

      if (isAs(nextToken)) {
        if (isDoubleQuotedString(afterNextToken)) {
          afterNextToken = removeFirstAndLastChar(afterNextToken)
        }

        sumExpression.AS = afterNextToken
        i = i + 2
      }

      json.SELECT.push(sumExpression)

      continue
    }

    if (isUpper(token)) {
      upperExpression = {}

      tokensEnclosedByParenthesis(tokens, i + 1).forEach(function (token) {
        i++

        if (['(', ',', ')'].indexOf(token) > -1) return

        if (isStringNumber(token)) {
          upperExpression.UPPER = parseFloat(token)
        } else {
          upperExpression.UPPER = token
        }
      })

      nextToken = tokens[i + 1]
      afterNextToken = tokens[i + 2]

      if (isAs(nextToken)) {
        if (isDoubleQuotedString(afterNextToken)) {
          afterNextToken = removeFirstAndLastChar(afterNextToken)
        }

        upperExpression.AS = afterNextToken
        i = i + 2
      }

      json.SELECT.push(upperExpression)

      continue
    }

    // String concatenation.

    if (isString(token)) {
      if (isStringOperator(nextToken)) {
        // TODO for loop to get larger string concatenations.
        json.SELECT.push([token, nextToken, afterNextToken])
        i = i + 2
      } else {
        json.SELECT.push(token)
      }

      continue
    }

    if (isStar(token)) json.SELECT.push(token)

    // After looking for functions and other keywords, check if it is
    // an expression enclosed by parenthesis, it could be a sub query.

    if ((token === '(') && (isSelect(nextToken))) {
      subQueryExpression = {}
      subQueryTokens = tokensEnclosedByParenthesis(tokens, i)

      i = i + subQueryTokens.length

      nextToken = tokens[i]
      afterNextToken = tokens[i + 1]

      // Remove left and right parenthesis
      subQueryTokens.shift()
      subQueryTokens.pop()

      if (isAs(nextToken)) {
        if (isDoubleQuotedString(afterNextToken)) {
          afterNextToken = removeFirstAndLastChar(afterNextToken)
        }

        subQueryExpression.AS = {}
        subQueryExpression.AS[afterNextToken] = select(subQueryTokens, sql)

        json.SELECT.push(subQueryExpression)

        i = i + 1
      } else {
        json.SELECT.push(select(subQueryTokens, sql))
      }
    }
  }

  // FROM
  // //////////////////////////////////////////////////////////////////////

  if (foundFrom) {
    json.FROM = []

    for (i = fromIndex + 1; i < numTokens; i++) {
      token = tokens[i]

      if (i < numTokens - 1) {
        nextToken = tokens[i + 1]
      } else {
        nextToken = null
      }

      if (isWhere(token)) {
        foundWhere = true
        whereIndex = i
      }

      if (isGroupBy(token)) {
        foundGroupBy = true
        groupByIndex = i
      }

      if (isHaving(token)) {
        foundHaving = true
        havingIndex = i
      }

      if (isOrderBy(token)) {
        foundOrderBy = true
        orderByIndex = i
      }

      if (isSetOperator(token)) {
        foundSetOperator = true
        setOperator = token
        setOperatorIndex = i
        break
      }

      if (foundWhere || foundGroupBy || foundHaving || foundOrderBy) continue

      if (token === ',') continue

      if (token === '(') {
        subQueryExpression = {}
        subQueryTokens = tokensEnclosedByParenthesis(tokens, i)

        // Remove left and right parenthesis
        subQueryTokens.shift()
        subQueryTokens.pop()

        i = i + subQueryTokens.length + 1

        nextToken = tokens[i + 1]
        afterNextToken = tokens[i + 2]

        nextTokenIsNotKeyword = (!isKeyword()(nextToken))
        nextTokenIsAlias = (isString(nextToken) && nextTokenIsNotKeyword)

        if (isSelect(subQueryTokens[0])) {
          if (nextTokenIsAlias) {
            if (isAnyJoin(afterNextToken)) {
              // TODO implement JOIN as below
              // test the following commented code.
              // joinKeyword = afterNextToken

              // subQueryExpression[joinKeyword] = join(tokens, i + 3, select, sql)

              // json.FROM.push(subQueryExpression)

              // i += countTokens(subQueryExpression[joinKeyword]) + 2

              // continue
            } else {
              subQueryExpression[nextToken] = select(subQueryTokens, sql)

              json.FROM.push(subQueryExpression)

              i = i + 2

              continue
            }
          } else {
            json.FROM.push(select(subQueryTokens, sql))

            continue
          }
        } else {
          // A sub query must start with a SELECT.
          throw error.invalidSQL(sql)
        }
      }

      if (isTableName(token)) {
        table = token
        nextToken = tokens[i + 1]
        afterNextToken = tokens[i + 2]

        nextTokenIsNotKeyword = (!isKeyword()(nextToken))
        nextTokenIsAlias = (isString(nextToken) && nextTokenIsNotKeyword)

        if (nextTokenIsAlias) {
          table = {}
          table[nextToken] = token

          if (isAnyJoin(afterNextToken)) {
            joinKeyword = afterNextToken

            table[joinKeyword] = join(tokens, i + 3, select, sql)

            json.FROM.push(table)

            i += countTokens(table[joinKeyword]) + 2

            continue
          } else {
            // Just a table alias with no JOIN expression.
            json.FROM.push(table)
            i = i + 1
            continue
          }
        } else {
          // If it is a common table name, add it to FROM list.
          json.FROM.push(table)
          continue
        }
      }
    }

    // WHERE
    // ////////////////////////////////////////////////////////////////////

    if (foundWhere) {
      // After a WHERE there should be at least one condition and it will
      // have more al least 3 tokens: leftOperand, operator, rightOperand.
      if (whereIndex === numTokens - 3) throw error.invalidSQL(sql)

      json.WHERE = condition(tokens, whereIndex, select, sql)
    }

    // GROUP BY
    // ////////////////////////////////////////////////////////////////////

    if (foundGroupBy) {
      json['GROUP BY'] = []

      for (i = groupByIndex + 1; i < numTokens; i++) {
        token = tokens[i]

        if (token === ',') continue

        // TODO probably this logic is incomplete
        if (isKeyword()(token)) break

        if (isStringNumber(token)) {
          token = parseFloat(token)
        }

        json['GROUP BY'].push(token)
      }
    }

    // HAVING
    // ////////////////////////////////////////////////////////////////////

    if (foundHaving) {
      // After a HAVING there should be at least one condition and it will
      // have more al least 3 tokens: leftOperand, operator, rightOperand.
      if (havingIndex === numTokens - 3) throw error.invalidSQL(sql)

      json.HAVING = condition(tokens, havingIndex, select, sql)
    }

    // ORDER BY
    // ////////////////////////////////////////////////////////////////////

    if (foundOrderBy) {
      json['ORDER BY'] = []

      for (i = orderByIndex + 1; i < numTokens; i++) {
        token = tokens[i]
        nextToken = tokens[i + 1]

        if (token === ',') continue

        // TODO probably this logic is incomplete
        if (isKeyword()(token)) break

        if (isStringNumber(token)) {
          token = parseFloat(token)
        }

        if (isDesc(nextToken)) {
          json['ORDER BY'].push({ DESC: token })
          i++
          continue
        }

        if (isAsc(nextToken)) {
          json['ORDER BY'].push({ ASC: token })
          i++
          continue
        }

        json['ORDER BY'].push(token)
      }
    }

    // LIMIT
    // ////////////////////////////////////////////////////////////////////

    for (i = fromIndex; i < numTokens; i++) {
      if (foundLimit) continue

      token = tokens[i]

      if (isLimit(token)) {
        foundLimit = true
        limitIndex = i
      }
    }

    if (foundLimit) {
      if (limitIndex === numTokens - 1) throw error.invalidSQL(sql)

      var limitValue = tokens[limitIndex + 1]

      if (isStringNumber(limitValue)) {
        limitValue = parseFloat(limitValue)

        if (limitValue >= 0) json.LIMIT = limitValue
        else throw error.invalidSQL(sql)
      } else {
        throw error.invalidSQL(sql)
      }
    }

    // OFFSET
    // ////////////////////////////////////////////////////////////////////

    for (i = fromIndex; i < numTokens; i++) {
      if (foundOffset) continue

      token = tokens[i]

      if (isOffset(token)) {
        foundOffset = true
        offsetIndex = i
      }
    }

    if (foundOffset) {
      if (offsetIndex === numTokens - 1) throw error.invalidSQL(sql)

      var offsetValue = tokens[offsetIndex + 1]

      if (isStringNumber(offsetValue)) {
        offsetValue = parseFloat(offsetValue)

        if (offsetValue >= 0) json.OFFSET = offsetValue
        else throw error.invalidSQL(sql)
      } else {
        throw error.invalidSQL(sql)
      }
    }
  }

  // EXCEPT INTERSECT, UNION, UNION ALL
  // ////////////////////////////////////////////////////////////////////

  if (foundSetOperator) {
    json[setOperator] = select(tokens.splice(setOperatorIndex + 1), sql)
  }

  return json
}

module.exports = select

},{"../error":1,"../util/countTokens":55,"../util/isAnyJoin":60,"../util/isDoubleQuotedString":64,"../util/isKeyword":66,"../util/isMathOperator":69,"../util/isSetOperator":74,"../util/isStar":76,"../util/isString":77,"../util/isStringNumber":78,"../util/isStringOperator":79,"../util/isTableName":81,"../util/removeFirstAndLastChar":88,"../util/tokensEnclosedByParenthesis":93,"./condition":4,"./join":9}],12:[function(require,module,exports){
var error = require('../error')

var doubleQuoteIfStringContainsSpace = require('../util/doubleQuoteIfStringContainsSpace')
var encloseWithParenthesis = require('../util/encloseWithParenthesis')
var isNumber = require('../util/isNumber')
var isObject = require('../util/isObject')
var isSelect = require('./isSelect')
var isString = require('../util/isString')
var stringField = require('./stringField')

/**
 * Stringify as AS expression.
 *
 * { AS: 'myalias' }  => ' AS myalias'
 * { AS: 'my count' } => ' AS "my count"'
 * { AS: { num: 1 } } => ' 1 AS num'
 * { AS: { num: { SELECT: ['foo'], FROM: ['mytable'] } } } => '(SELECT foo FROM mytable) AS num'
 * { }                => ''
 *
 * @param {Object} json
 * @param {Function} [select]
 *
 * @returns {String} result
 */

function aliasExpression (json, select) {
  var alias
  var field
  var result = ''

  var AS = json.AS

  if (isString(AS)) {
    result += ' AS ' + doubleQuoteIfStringContainsSpace(AS)
  }

  if (isObject(AS)) {
    alias = Object.keys(AS)

    if (alias.length > 1) {
      throw error.invalidAlias(json)
    } else {
      // Alias is ok, it must contain only one key, the alias.
      alias = alias[0]
    }

    field = AS[alias]

    if (isNumber(field)) result = field

    if (isString(field)) result = stringField(field)

    if (isSelect(field)) {
      if (typeof select === 'function') {
        result = encloseWithParenthesis(select(field))
      } else {
        throw error.functionRequired('select')
      }
    }

    result += ' AS ' + doubleQuoteIfStringContainsSpace(alias)
  }

  return result
}

module.exports = aliasExpression

},{"../error":1,"../util/doubleQuoteIfStringContainsSpace":57,"../util/encloseWithParenthesis":58,"../util/isNumber":70,"../util/isObject":72,"../util/isString":77,"./isSelect":43,"./stringField":51}],13:[function(require,module,exports){
var error = require('../error')

var aliasExpression = require('./aliasExpression')
var isString = require('../util/isString')

/**
 * Stringify AVG expression
 *
 * @param {Object} json
 *
 * @returns {String} result
 */

function avgExpression (json) {
  var result = ''

  var AVG = json.AVG

  if (isString(AVG)) {
    result = 'AVG(' + AVG + ')'
    return result + aliasExpression(json)
  }

  // Should not arrive here.
  throw error.couldNotParseSelectField(AVG)
}

module.exports = avgExpression

},{"../error":1,"../util/isString":77,"./aliasExpression":12}],14:[function(require,module,exports){
var filter = require('./filter')

/**
 * Extract filter conditions.
 *
 * @param {Function} select
 *
 * @returns {Function} stringifyConditions
 */

function conditions (select) {
  /**
  * @param {Array} conditions
  *
  * @returns {String} result
  */

  return function stringifyConditions (conditions) {
    var firstField = conditions.shift()
    var firstFilter = conditions.shift()

    var strinfigyFilter = filter(select)

    var result = firstField + ' ' + strinfigyFilter(firstFilter)

    for (var i = 0; i < conditions.length; i++) {
      result += ' ' + strinfigyFilter(conditions[i])
    }

    return result
  }
}

module.exports = conditions

},{"./filter":19}],15:[function(require,module,exports){
var aliasExpression = require('./aliasExpression')
var isStar = require('../util/isStar')
var isString = require('../util/isString')

/**
 * Stringify COUNT expression
 *
 * @param {Object} json
 *
 * @returns {String} result
 */

function countExpression (json) {
  var result = ''

  var COUNT = json.COUNT

  if (isStar(COUNT)) result = 'COUNT(*)'
  if (COUNT === 1) result = 'COUNT(1)'

  if (isString(COUNT)) {
    if (json.DISTINCT) {
      result = 'COUNT(DISTINCT ' + COUNT + ')'
    } else {
      result = 'COUNT(' + COUNT + ')'
    }
  }

  return result + aliasExpression(json)
}

module.exports = countExpression

},{"../util/isStar":76,"../util/isString":77,"./aliasExpression":12}],16:[function(require,module,exports){
function createTable (json, stringify) {
  var CREATE_TABLE = json['CREATE TABLE']

  var sql = 'CREATE TABLE ' + CREATE_TABLE.name

  var tableFields = CREATE_TABLE.fields

  if (tableFields) {
    sql += ' ('

    tableFields.forEach(function (field, index, fields) {
      sql += field[0] + ' ' + field[1]

      if (index === fields.length - 1) {
        sql += ')'
      } else {
        sql += ', '
      }
    })
  }

  if (CREATE_TABLE.AS) sql += ' AS ' + stringify(CREATE_TABLE.AS)

  return sql
}

module.exports = createTable

},{}],17:[function(require,module,exports){
var conditions = require('./conditions')
var hasWhere = require('./hasWhere')
var select = require('./select')

function deleteFrom (json) {
  var tableName = json['DELETE FROM']

  var sql = 'DELETE FROM ' + tableName

  if (json.WHERE) {
    if (hasWhere(json)) {
      sql += ' WHERE ' + conditions(select)(json.WHERE)
    }
  }

  return sql
}

module.exports = deleteFrom

},{"./conditions":14,"./hasWhere":34,"./select":49}],18:[function(require,module,exports){
function dropTable (json) {
  var tableName = json['DROP TABLE']

  return 'DROP TABLE ' + tableName
}

module.exports = dropTable

},{}],19:[function(require,module,exports){
var error = require('../error')

var encloseWithParenthesis = require('../util/encloseWithParenthesis')
var isBetween = require('./isBetween')
var isLike = require('./isLike')
var isNotLike = require('./isNotLike')
var isNotBetween = require('./isNotBetween')
var isSelect = require('./isSelect')
var quoteIfString = require('../util/quoteIfString')

var isArray = Array.isArray

var comparisonOperators = require('../util/comparisonOperators.json')

/**
 * Extract filter.
 *
 * @param {Function} select
 *
 * @returns {Function} stringifyFilter
 */

function filter (select) {
  /**
  *
  * @param {Object} filter
  *
  * @returns {String} result
  */

  return function stringifyFilter (filter) {
    var i

    for (i = 0; i < comparisonOperators.length; i++) {
      var operator = comparisonOperators[i]
      var operand = filter[operator]

      if (isArray(operand)) {
        return operator + ' ' + operand.join(' ')
      }

      if (typeof operand !== 'undefined') {
        return operator + ' ' + operand
      }
    }

    var IN = filter.IN

    if (IN) {
      if (isArray(IN)) {
        return 'IN ' + encloseWithParenthesis(filter.IN.map(quoteIfString).join(', '))
      }

      if (isSelect(IN)) {
        if (typeof select === 'function') {
          return 'IN ' + encloseWithParenthesis(select(IN))
        } else {
          throw error.functionRequired('select')
        }
      }
    }

    var AND = filter.AND

    if (isArray(AND)) {
      var stringyfiedAND = AND[0] + ' ' + stringifyFilter(AND[1])

      for (i = 2; i < AND.length; i++) {
        stringyfiedAND += ' ' + stringifyFilter(AND[i])
      }

      if (AND.length === 2) {
        return 'AND ' + stringyfiedAND
      } else {
        return 'AND ' + encloseWithParenthesis(stringyfiedAND)
      }
    }

    var BETWEEN = filter.BETWEEN

    if (isBetween(filter)) {
      return 'BETWEEN ' + BETWEEN.join(' AND ')
    }

    var NOT_BETWEEN = filter['NOT BETWEEN']

    if (isNotBetween(filter)) {
      return 'NOT BETWEEN ' + NOT_BETWEEN.join(' AND ')
    }

    var LIKE = filter.LIKE

    if (isLike(filter)) {
      return 'LIKE ' + LIKE
    }

    var NOT_LIKE = filter['NOT LIKE']

    if (isNotLike(filter)) {
      return 'NOT LIKE ' + NOT_LIKE
    }

    var OR = filter.OR

    if (isArray(OR)) {
      var stringyfiedOR = OR[0] + ' ' + stringifyFilter(OR[1])

      for (i = 2; i < OR.length; i++) {
        stringyfiedOR += ' ' + stringifyFilter(OR[i])
      }

      if (OR.length === 2) {
        return 'OR ' + stringyfiedOR
      } else {
        return 'OR ' + encloseWithParenthesis(stringyfiedOR)
      }
    }
  }
}

module.exports = filter

},{"../error":1,"../util/comparisonOperators.json":54,"../util/encloseWithParenthesis":58,"../util/quoteIfString":87,"./isBetween":36,"./isLike":40,"./isNotBetween":41,"./isNotLike":42,"./isSelect":43}],20:[function(require,module,exports){
var isAnyJoin = require('../util/isAnyJoin')

function getJoinKeyword (statement) {
  var keys = Object.keys(statement)

  for (var i = 0; i < keys.length; i++) {
    var token = keys[i]

    if (isAnyJoin(token)) return token
  }
}

module.exports = getJoinKeyword

},{"../util/isAnyJoin":60}],21:[function(require,module,exports){
var isKeyword = require('../util/isKeyword')
var isSelect = require('./isSelect')

/**
 * Extract result set alias, and check that result set is a SELECT.
 *
 * { t: { SELECT: ['foo'], FROM ['mytable'] } } => t
 *
 * @param {Object} json
 *
 * @returns {String|undefined} alias
 */

function getResultSetAlias (json) {
  var keys = Object.keys(json)
  var resultSet

  for (var i = 0; i < keys.length; i++) {
    var token = keys[i]

    if (isKeyword()(token)) continue

    resultSet = json[token]

    if (isSelect(resultSet)) {
      return token
    } else {
      return
    }
  }
}

module.exports = getResultSetAlias

},{"../util/isKeyword":66,"./isSelect":43}],22:[function(require,module,exports){
var getResultSetAlias = require('./getResultSetAlias')
var isKeyword = require('../util/isKeyword')
var isAs = isKeyword('AS')

/**
 * Extract result set with alias.
 *
 * { t: { SELECT: ['foo'], FROM: ['mytable']} , JOIN: {} } => { t: { SELECT: ['foo'], FROM: ['mytable'] } }
 * { AS: { t: { SELECT: ['foo'], FROM: ['mytable'] } }, JOIN: {} } => { AS: { t: { SELECT: ['foo'], FROM: ['mytable'] } } }
 *
 * @param {Object} json
 *
 * @returns {Object|undefined}
 */

function getResultSetWithAlias (json) {
  var keys = Object.keys(json)
  var resultSetObj
  var resultSet

  var alias = getResultSetAlias(json)

  if (alias) {
    resultSetObj = {}
    resultSet = json[alias]
    resultSetObj[alias] = resultSet
  } else {
    for (var i = 0; i < keys.length; i++) {
      var token = keys[i]

      if (isAs(token)) {
        alias = getResultSetAlias(json[token])

        if (alias) {
          resultSetObj = { AS: json[token] }
          break
        } else {
          return
        }
      }
    }
  }

  return resultSetObj
}

module.exports = getResultSetWithAlias

},{"../util/isKeyword":66,"./getResultSetAlias":21}],23:[function(require,module,exports){
var isKeyword = require('../util/isKeyword')
var isTableName = require('../util/isTableName')

/**
 * Extract table name alias and check that table name is valid.
 *
 * { t: 'mytable' } => t
 *
 * @param {Object} json
 *
 * @returns {String|undefined} alias
 */

function getTableNameAlias (json) {
  var keys = Object.keys(json)
  var tableName

  for (var i = 0; i < keys.length; i++) {
    var token = keys[i]

    if (isKeyword()(token)) continue

    tableName = json[token]

    if (isTableName(tableName)) {
      return token
    } else {
      return
    }
  }
}

module.exports = getTableNameAlias

},{"../util/isKeyword":66,"../util/isTableName":81}],24:[function(require,module,exports){
var getTableNameAlias = require('./getTableNameAlias')
var isKeyword = require('../util/isKeyword')
var isAs = isKeyword('AS')

/**
 * Extract table name with alias.
 *
 * { t: 'mytable', JOIN: {} } => { t: 'mytable' }
 * { AS: { t: 'mytable' }, JOIN: {} } => { AS: { t: 'mytable' } }
 *
 * @param {Object} json
 *
 * @returns {Object|undefined}
 */

function getTableNameWithAlias (json) {
  var keys = Object.keys(json)
  var tableObj
  var tableName

  var alias = getTableNameAlias(json)

  if (alias) {
    tableObj = {}
    tableName = json[alias]
    tableObj[alias] = tableName
  } else {
    for (var i = 0; i < keys.length; i++) {
      var token = keys[i]

      if (isAs(token)) {
        alias = getTableNameAlias(json[token])

        if (alias) {
          tableObj = { AS: json[token] }
          break
        } else {
          return
        }
      }
    }
  }

  return tableObj
}

module.exports = getTableNameWithAlias

},{"../util/isKeyword":66,"./getTableNameAlias":23}],25:[function(require,module,exports){
var isString = require('../util/isString')

/**
 * Can map a list of GROUP BY directives to a SQL statement.
 *
 * "field1" => "field1"
 *
 * @param {Object|String} condition
 *
 * @returns {String} result
 */

function groupByCondition (condition) {
  if (isString(condition)) return condition
}

module.exports = groupByCondition

},{"../util/isString":77}],26:[function(require,module,exports){
var error = require('../error')

/**
 * Check that expression has a SELECT.
 *
 * { FROM: ['mytable'] } => true
 *
 * @param {Object} json
 *
 * @returns {Boolean}
 */

function hasFrom (json) {
  var FROM = json.FROM

  if (FROM) {
    if (Array.isArray(FROM) && FROM.length > 0) {
      return true
    } else {
      throw error.invalidJSONData({ FROM: FROM })
    }
  } else {
    return false
  }
}

module.exports = hasFrom

},{"../error":1}],27:[function(require,module,exports){
var isNumberOrString = require('../util/isNumberOrString')

/**
 * Check that expression has a GROUP BY.
 *
 * { 'GROUP BY': [1] } => true
 * { 'GROUP BY': ['name'] } => true
 *
 * @param {Object} json
 *
 * @returns {Boolean}
 */

function hasGroupBy (json) {
  var GROUP_BY = json['GROUP BY']

  return Array.isArray(GROUP_BY) && GROUP_BY.length > 0 && GROUP_BY.filter(isNumberOrString).length === GROUP_BY.length
}

module.exports = hasGroupBy

},{"../util/isNumberOrString":71}],28:[function(require,module,exports){
/**
 * Check that expression contains a HAVING.
 *
 * { } => false
 * { HAVING: [] } => false
 * { HAVING: [ yyyymmdd, { '=': 20170209 } ] } => true
 *
 * @param {Object} json
 *
 * @returns {Boolean}
 */

function hasHaving (json) {
  return Array.isArray(json.HAVING) && json.HAVING.length > 1
}

module.exports = hasHaving

},{}],29:[function(require,module,exports){
/**
 * Check that expression contains a LIMIT.
 *
 * { LIMIT: 100 } => true
 *
 * @param {Object} json
 *
 * @returns {Boolean}
 */

function hasLimit (json) {
  var limit = json.LIMIT

  return typeof limit === 'number' && limit > 0
}

module.exports = hasLimit

},{}],30:[function(require,module,exports){
/**
 * Check that expression contains an OFFSET.
 *
 * { OFFSET: 0 } => false
 * { OFFSET: 100 } => true
 *
 * @param {Object} json
 *
 * @returns {Boolean}
 */

function hasOffset (json) {
  var offset = json.OFFSET

  return typeof offset === 'number' && offset > 0
}

module.exports = hasOffset

},{}],31:[function(require,module,exports){
var isNumberOrString = require('../util/isNumberOrString')
var isObject = require('../util/isObject')

/**
 * Check that expression has an ORDER_BY BY.
 *
 * { 'ORDER BY': [1] } => true
 * { 'ORDER BY': [ { DESC: 'name' } ] } => true
 *
 * @param {Object} json
 *
 * @returns {Boolean}
 */

function hasOrderBy (json) {
  var ORDER_BY = json['ORDER BY']
  if (!ORDER_BY) return false

  var isArrayWithElements = Array.isArray(ORDER_BY) && ORDER_BY.length > 0
  if (!isArrayWithElements) return false

  function validElements (element) {
    if (isNumberOrString(element)) return true

    if (isObject(element)) {
      if (isNumberOrString(element.DESC)) return true
      if (isNumberOrString(element.ASC)) return true
    }

    return false
  }

  var allElementsAreOk = ORDER_BY.filter(validElements).length === ORDER_BY.length

  return allElementsAreOk
}

module.exports = hasOrderBy

},{"../util/isNumberOrString":71,"../util/isObject":72}],32:[function(require,module,exports){
var isSelect = require('./isSelect')

/**
 * Check that expression has a UNION.
 *
 * { SELECT: 2, UNION: [ { SELECT: 1 } ] } => true
 *
 * @param {Object} json
 *
 * @returns {Boolean}
 */

function hasUnion (json) {
  var UNION = json.UNION

  return UNION && isSelect(UNION)
}

module.exports = hasUnion

},{"./isSelect":43}],33:[function(require,module,exports){
var isSelect = require('./isSelect')

/**
 * Check that expression has a UNION ALL.
 *
 * { SELECT: 2, 'UNION ALL': [ { SELECT: 1 } ] } => true
 *
 * @param {Object} json
 *
 * @returns {Boolean}
 */

function hasUnionAll (json) {
  var UNION_ALL = json['UNION ALL']

  return UNION_ALL && isSelect(UNION_ALL)
}

module.exports = hasUnionAll

},{"./isSelect":43}],34:[function(require,module,exports){
/**
 * Check that expression contains a WHERE.
 *
 * { } => false
 * { WHERE: [] } => false
 * { WHERE: [ yyyymmdd, { '=': 20170209 } ] } => true
 *
 * @param {Object} json
 *
 * @returns {Boolean}
 */

function hasWhere (json) {
  return Array.isArray(json.WHERE) && json.WHERE.length > 1
}

module.exports = hasWhere

},{}],35:[function(require,module,exports){
var isCreateTable = require('./isCreateTable')
var isDeleteFrom = require('./isDeleteFrom')
var isDropTable = require('./isDropTable')
var isSelect = require('./isSelect')

var createTable = require('./createTable')
var deleteFrom = require('./deleteFrom')
var dropTable = require('./dropTable')
var select = require('./select')

/**
 * Convert JSON to SQL.
 *
 * @param {Object} json
 *
 * @returns {String} sql
 */

function stringify (json) {
  var sql = ''

  if (isDeleteFrom(json)) {
    return deleteFrom(json)
  }

  if (isDropTable(json)) {
    return dropTable(json)
  }

  if (isCreateTable(json, stringify)) {
    sql = createTable(json, stringify)
  }

  if (isSelect(json)) {
    // A SELECT statement could be a continuation of an INSERT,
    // or a CREATE TABLE foo AS, so it is necessary to add a
    // space separator in between.
    if (sql !== '') sql += ' '

    sql += select(json, sql)
  }

  return sql
}

module.exports = stringify

},{"./createTable":16,"./deleteFrom":17,"./dropTable":18,"./isCreateTable":37,"./isDeleteFrom":38,"./isDropTable":39,"./isSelect":43,"./select":49}],36:[function(require,module,exports){
var isNumberOrString = require('../util/isNumberOrString')

/**
 * Check that filter is a BETWEEN expression.
 *
 * { BETWEEN: [10, 20] } => true
 *
 * @param {Object} json
 *
 * @returns {Boolean}
 */

function isBetween (json) {
  var BETWEEN = json.BETWEEN

  return Array.isArray(BETWEEN) && BETWEEN.length === 2 && isNumberOrString(BETWEEN[0]) && isNumberOrString(BETWEEN[1])
}

module.exports = isBetween

},{"../util/isNumberOrString":71}],37:[function(require,module,exports){
var isDataType = require('../util/isDataType')
var isTableName = require('../util/isTableName')
var isSelect = require('./isSelect')
var isValidName = require('../util/isValidName')

/**
 * Check that expression is a CREATE TABLE.
 *
 * {
 *   'CREATE TABLE': {
 *     name: 'mytable',
 *     fields: [
 *       [ 'ok', 'BOOLEAN' ]
 *     ]
 * } => true
 *
 * {
 *   'CREATE TABLE': {
 *     name: 'mytable',
 *     AS: { SELECT ['*'], FROM: ['foo'] }
 * } => true
 *
 * @param {Object} json
 *
 * @returns {Boolean}
 */

function isCreateTable (json) {
  var CREATE_TABLE = json['CREATE TABLE']

  if (!CREATE_TABLE) return false

  if (!isTableName(CREATE_TABLE.name)) return false

  if (Array.isArray(CREATE_TABLE.fields)) {
    var numFields = CREATE_TABLE.fields.length

    if (numFields === 0) return false

    for (var i = 0; i < numFields; i++) {
      var field = CREATE_TABLE.fields[i]

      if (!isValidName(field[0])) return false
      if (!isDataType(field[1])) return false
    }

    return true
  }

  if (isSelect(CREATE_TABLE.AS)) return true

  return false
}

module.exports = isCreateTable

},{"../util/isDataType":63,"../util/isTableName":81,"../util/isValidName":82,"./isSelect":43}],38:[function(require,module,exports){
var isTableName = require('../util/isTableName')

/**
 * Check that expression is a DELETE FROM.
 *
 * {
 *   'DELETE FROM': 'mytable'
 * } => true
 *
 * @param {Object} json
 *
 * @returns {Boolean}
 */

function isDeleteFrom (json) {
  var tableName = json['DELETE FROM']

  if (!tableName) return false

  return isTableName(tableName)
  // TODO check WHERE condition
}

module.exports = isDeleteFrom

},{"../util/isTableName":81}],39:[function(require,module,exports){
var isTableName = require('../util/isTableName')

/**
 * Check that expression is a DROP TABLE.
 *
 * {
 *   'DROP TABLE': 'mytable'
 * } => true
 *
 * @param {Object} json
 *
 * @returns {Boolean}
 */

function isDropTable (json) {
  var tableName = json['DROP TABLE']

  if (!tableName) return false

  return isTableName(tableName)
}

module.exports = isDropTable

},{"../util/isTableName":81}],40:[function(require,module,exports){
var isSingleQuotedString = require('../util/isSingleQuotedString')

/**
 * Check that filter is a LIKE expression.
 *
 * { LIKE: '%foo' } => true
 *
 * @param {Object} json
 *
 * @returns {Boolean}
 */

function isLike (json) {
  var LIKE = json.LIKE

  return isSingleQuotedString(LIKE)
}

module.exports = isLike

},{"../util/isSingleQuotedString":75}],41:[function(require,module,exports){
var isNumberOrString = require('../util/isNumberOrString')

/**
 * Check that filter is a NOT BETWEEN expression.
 *
 * { 'NOT BETWEEN': [10, 20] } => true
 *
 * @param {Object} json
 *
 * @returns {Boolean}
 */

function isNotBetween (json) {
  var NOT_BETWEEN = json['NOT BETWEEN']

  return Array.isArray(NOT_BETWEEN) && NOT_BETWEEN.length === 2 && isNumberOrString(NOT_BETWEEN[0]) && isNumberOrString(NOT_BETWEEN[1])
}

module.exports = isNotBetween

},{"../util/isNumberOrString":71}],42:[function(require,module,exports){
var isSingleQuotedString = require('../util/isSingleQuotedString')

/**
 * Check that filter is a NOT LIKE expression.
 *
 * { 'NOT LIKE': '%foo' } => true
 *
 * @param {Object} json
 *
 * @returns {Boolean}
 */

function isNotLike (json) {
  var NOT_LIKE = json['NOT LIKE']

  return isSingleQuotedString(NOT_LIKE)
}

module.exports = isNotLike

},{"../util/isSingleQuotedString":75}],43:[function(require,module,exports){
/**
 * Check that expression is a SELECT.
 *
 * { SELECT: [1] } => true
 *
 * @param {Object} json
 *
 * @returns {Boolean}
 */

function isSelect (json) {
  var SELECT = json.SELECT

  return Array.isArray(SELECT) && SELECT.length > 0
}

module.exports = isSelect

},{}],44:[function(require,module,exports){
var aliasExpression = require('./aliasExpression')
var isString = require('../util/isString')

/**
 * Stringify MAX expression
 *
 * @param {Object} json
 *
 * @returns {String} result
 */

function maxExpression (json) {
  var result = ''

  var MAX = json.MAX

  if (isString(MAX)) result = 'MAX(' + MAX + ')'

  return result + aliasExpression(json)
}

module.exports = maxExpression

},{"../util/isString":77,"./aliasExpression":12}],45:[function(require,module,exports){
var aliasExpression = require('./aliasExpression')
var isString = require('../util/isString')

/**
 * Stringify MIN expression
 *
 * @param {Object} json
 *
 * @returns {String} result
 */

function minExpression (json) {
  var result = ''

  var MIN = json.MIN

  if (isString(MIN)) result = 'MIN(' + MIN + ')'

  return result + aliasExpression(json)
}

module.exports = minExpression

},{"../util/isString":77,"./aliasExpression":12}],46:[function(require,module,exports){
var aliasExpression = require('./aliasExpression')

/**
 * Stringify NVL expression
 *
 * @param {Object} json
 *
 * @returns {String} result
 */

function nvlExpression (json) {
  var result = ''

  var NVL = json.NVL

  result = 'NVL(' + NVL[0] + ', ' + NVL[1] + ')'

  return result + aliasExpression(json)
}

module.exports = nvlExpression

},{"./aliasExpression":12}],47:[function(require,module,exports){
var isNumberOrString = require('../util/isNumberOrString')
var isObject = require('../util/isObject')

/**
 * Can map a list of ORDER BY directives to a SQL statement.
 *
 * { DESC: 2 } => 2 DESC
 *
 * @param {Object|String} condition
 *
 * @returns {String} result
 */

function orderByCondition (condition) {
  if (isNumberOrString(condition)) return condition

  if (isObject(condition)) {
    if (isNumberOrString(condition.DESC)) return condition.DESC + ' DESC'
    if (isNumberOrString(condition.ASC)) return condition.ASC + ' ASC'
  }
}

module.exports = orderByCondition

},{"../util/isNumberOrString":71,"../util/isObject":72}],48:[function(require,module,exports){
var conditions = require('./conditions')
var encloseWithParenthesis = require('../util/encloseWithParenthesis')
var getTableNameAlias = require('./getTableNameAlias')
var getTableNameWithAlias = require('./getTableNameWithAlias')
var getResultSetAlias = require('./getResultSetAlias')
var getResultSetWithAlias = require('./getResultSetWithAlias')
var getJoinKeyword = require('./getJoinKeyword')
var isTableName = require('../util/isTableName')
var isSelect = require('./isSelect')

/**
 * A result set is given by a table name or a SELECT statement.
 *
 * @param {Function} select
 *
 * @returns {Function} stringifyResultSet
 */

function resultSet (select) {
  /**
  * Stringify resultset
  *
  * @param {String|Object} statement
  * @param {Boolean} [notFirstJoin]
  *
  * @returns {String} result
  */

  return function stringifyResultSet (statement, notFirstJoin) {
    if (isTableName(statement)) {
      return statement
    }

    if (isSelect(statement)) {
      return encloseWithParenthesis(select(statement))
    }

    var result = ''

    var resultSetWithAlias = getResultSetWithAlias(statement)

    if (resultSetWithAlias) {
      var resultSetAlias = getResultSetAlias(resultSetWithAlias)
      var resultSetObj = resultSetWithAlias[resultSetAlias]

      result = encloseWithParenthesis(select(resultSetObj)) + ' ' + resultSetAlias

      // TODO implement JOIN also here

      return result
    }

    var tableNameWithAlias = getTableNameWithAlias(statement)

    if (tableNameWithAlias) {
      var tableAlias = getTableNameAlias(tableNameWithAlias)
      var tableName = tableNameWithAlias[tableAlias]
      var joinKeyword = getJoinKeyword(statement)
      var joinObj = statement[joinKeyword]

      if (joinKeyword) {
        result = notFirstJoin ? '' : tableName + ' ' + tableAlias + ' '

        var joinTableNameWithAlias = getTableNameWithAlias(joinObj)

        if (joinTableNameWithAlias) {
          var joinTableAlias = getTableNameAlias(joinTableNameWithAlias)
          var joinTableName = joinTableNameWithAlias[joinTableAlias]
          var onCondition = joinObj.ON.slice(0)

          result += [joinKeyword, joinTableName, joinTableAlias].join(' ')
          result += ' ON ' + conditions(select)(onCondition)
        }

        // TODO statement like JOIN (select * from table) t
        // use getResultSetWithAlias()

        var nextJoinKeyword = getJoinKeyword(joinObj)

        if (nextJoinKeyword) {
          var nextJoinStatement = {}
          notFirstJoin = true
          nextJoinStatement[nextJoinKeyword] = joinObj[nextJoinKeyword]
          result += ' ' + stringifyResultSet(joinObj, notFirstJoin)
        }
      } else {
        // No JOIN found.
        result = tableName + ' ' + tableAlias
      }

      return result
    }
  }
}

module.exports = resultSet

},{"../util/encloseWithParenthesis":58,"../util/isTableName":81,"./conditions":14,"./getJoinKeyword":20,"./getResultSetAlias":21,"./getResultSetWithAlias":22,"./getTableNameAlias":23,"./getTableNameWithAlias":24,"./isSelect":43}],49:[function(require,module,exports){
var conditions = require('./conditions')
var groupByCondition = require('./groupByCondition')
var hasFrom = require('./hasFrom')
var hasLimit = require('./hasLimit')
var hasOffset = require('./hasOffset')
var hasGroupBy = require('./hasGroupBy')
var hasHaving = require('./hasHaving')
var hasOrderBy = require('./hasOrderBy')
var hasUnion = require('./hasUnion')
var hasUnionAll = require('./hasUnionAll')
var hasWhere = require('./hasWhere')
var orderByCondition = require('./orderByCondition')
var resultSet = require('./resultSet')
var selectField = require('./selectField')

/**
 * Stringify SELECT statement.
 *
 * @param {Object} json
 *
 * @returns {String} sql
 */

function select (json) {
  var sql = 'SELECT '

  if (json.DISTINCT) sql += 'DISTINCT '

  sql += json.SELECT.map(function (field) { return selectField(field, select) }).join(', ')

  if (hasFrom(json)) {
    sql += ' FROM ' + json.FROM.map(resultSet(select)).join(' ')
  }

  if (hasWhere(json)) {
    sql += ' WHERE ' + conditions(select)(json.WHERE)
  }

  if (hasGroupBy(json)) {
    sql += ' GROUP BY ' + json['GROUP BY'].map(groupByCondition).join(', ')

    if (hasHaving(json)) {
      sql += ' HAVING ' + conditions(select)(json.HAVING)
    }
  }

  if (hasOrderBy(json)) {
    sql += ' ORDER BY ' + json['ORDER BY'].map(orderByCondition).join(', ')
  }

  if (hasLimit(json)) {
    sql += ' LIMIT ' + json.LIMIT
  }

  if (hasOffset(json)) {
    sql += ' OFFSET ' + json.OFFSET
  }

  if (hasUnion(json)) {
    sql += ' UNION ' + select(json.UNION)
  }

  if (hasUnionAll(json)) {
    sql += ' UNION ALL ' + select(json['UNION ALL'])
  }

  return sql
}

module.exports = select

},{"./conditions":14,"./groupByCondition":25,"./hasFrom":26,"./hasGroupBy":27,"./hasHaving":28,"./hasLimit":29,"./hasOffset":30,"./hasOrderBy":31,"./hasUnion":32,"./hasUnionAll":33,"./hasWhere":34,"./orderByCondition":47,"./resultSet":48,"./selectField":50}],50:[function(require,module,exports){
var error = require('../error')

var aliasExpression = require('./aliasExpression')
var avgExpression = require('./avgExpression')
var countExpression = require('./countExpression')
// var isMathOperator = require('../util/isMathOperator')
var encloseWithParenthesis = require('../util/encloseWithParenthesis')
var isNumber = require('../util/isNumber')
var isObject = require('../util/isObject')
// var isStringOperator = require('../util/isStringOperator')
var isSelect = require('./isSelect')
var isStar = require('../util/isStar')
var isString = require('../util/isString')
var maxExpression = require('./maxExpression')
var minExpression = require('./minExpression')
var nvlExpression = require('./nvlExpression')
var stringField = require('./stringField')
var sumExpression = require('./sumExpression')

var unaryFunction = require('./unaryFunction')

var lowerExpression = unaryFunction('LOWER')
var upperExpression = unaryFunction('UPPER')

/**
 * Map columns in a SELECT.
 *
 * @param {Number|String|Object} field
 * @param {Function} [select]
 *
 * @returns {String} result
 */

function selectField (field, select) {
  // Field could be a subquery.

  if (isSelect(field)) {
    if (typeof select === 'function') {
      return encloseWithParenthesis(select(field))
    } else {
      throw error.functionRequired('select')
    }
  }

  // Check if field is a math or string expression.
  if (Array.isArray(field)) {
    // TODO improve this using isMathOperator and isStringOperator
    return field.join(' ')
  }

  if (isStar(field)) return field

  if (isNumber(field)) return field

  if (isString(field)) {
    return stringField(field)
  }

  if (isObject(field)) {
    if (field.AVG) {
      return avgExpression(field)
    }

    if (field.COUNT) {
      return countExpression(field)
    }

    if (field.LOWER) {
      return lowerExpression(field)
    }

    if (field.MAX) {
      return maxExpression(field)
    }

    if (field.MIN) {
      return minExpression(field)
    }

    if (field.NVL) {
      return nvlExpression(field)
    }

    if (field.SUM) {
      return sumExpression(field)
    }

    if (field.UPPER) {
      return upperExpression(field)
    }

    // Check if it is an alias. This must be the last check since
    // other expressions can contain aliases.
    // I could also be an aliased sub query.
    if (field.AS) {
      return aliasExpression(field, select)
    }
  }

  // Should not arrive here.
  throw error.couldNotParseSelectField(field)
}

module.exports = selectField

},{"../error":1,"../util/encloseWithParenthesis":58,"../util/isNumber":70,"../util/isObject":72,"../util/isStar":76,"../util/isString":77,"./aliasExpression":12,"./avgExpression":13,"./countExpression":15,"./isSelect":43,"./maxExpression":44,"./minExpression":45,"./nvlExpression":46,"./stringField":51,"./sumExpression":52,"./unaryFunction":53}],51:[function(require,module,exports){
var isDataType = require('../util/isDataType')
var isFieldName = require('../util/isFieldName')
var isSingleQuotedString = require('../util/isSingleQuotedString')
var isStringNumber = require('../util/isStringNumber')

function stringField (field) {
  // Consider that a field could be casted, for example
  //
  // SELECT 1::VARCHAR

  var fieldName = field.split('::')[0]
  var dataType = field.split('::')[1]

  var fieldNameIsValid = isStringNumber(fieldName) || isSingleQuotedString(fieldName) || isFieldName(fieldName)

  if (dataType) {
    if (fieldNameIsValid && isDataType(dataType)) return field
  } else {
    if (fieldNameIsValid) return field
  }
}

module.exports = stringField

},{"../util/isDataType":63,"../util/isFieldName":65,"../util/isSingleQuotedString":75,"../util/isStringNumber":78}],52:[function(require,module,exports){
var aliasExpression = require('./aliasExpression')
var isString = require('../util/isString')

/**
 * Stringify SUM expression
 *
 * @param {Object} json
 *
 * @returns {String} result
 */

function sumExpression (json) {
  var result = ''

  var SUM = json.SUM

  if (isString(SUM)) result = 'SUM(' + SUM + ')'

  return result + aliasExpression(json)
}

module.exports = sumExpression

},{"../util/isString":77,"./aliasExpression":12}],53:[function(require,module,exports){
var aliasExpression = require('./aliasExpression')
var isString = require('../util/isString')
var stringField = require('./stringField')

/**
 * Stringify unary function expression, like MAX, MIN, UPPER, LOWER.
 *
 * @param {String} functionName
 *
 * @returns {String} result
 */

function unaryFunction (functionName) {
  /**
  * @param {Object} json
  *
  * @returns {String} result
  */

  return function (json) {
    var result = ''

    var expression = json[functionName]

    // TODO
    // 1. isString should be isField
    // 2. should check for math expressions and other stuff
    if (isString(expression)) {
      result = functionName + '(' + stringField(expression) + ')'
    }

    return result + aliasExpression(json)
  }
}

module.exports = unaryFunction

},{"../util/isString":77,"./aliasExpression":12,"./stringField":51}],54:[function(require,module,exports){
module.exports=["=", ">", "<", "<>", "<=", ">=", "!="]

},{}],55:[function(require,module,exports){
/**
 * Count how many tokens that are in given JSON.
 *
 * { SELECT: [1] } => 2
 * [ "a", { "=": "b" } ] => 3
 *
 * @params {String|Number|Array|Object} json
 *
 * @returns {Number} count
 */

function countTokens (json) {
  var count = 0
  var keys

  if (typeof json === 'number') return 1
  if (typeof json === 'string') return 1

  if (typeof json === 'object') {
    if (Array.isArray(json)) {
      for (var i = 0; i < json.length; i++) {
        count += countTokens(json[i])
      }
    } else {
      keys = Object.keys(json)

      for (var j = 0; j < keys.length; j++) {
        count += countTokens(json[keys[j]]) + 1
      }
    }
  }

  return count
}

module.exports = countTokens

},{}],56:[function(require,module,exports){
module.exports=[
  "BOOLEAN",
  "CHARACTER",
  "CHARACTER VARYING",
  "DATE",
  "DECIMAL",
  "FLOAT",
  "INTEGER",
  "INTERVAL",
  "NUMERIC",
  "SMALLINT",
  "TIME",
  "TIMESTAMP",
  "VARCHAR"
]

},{}],57:[function(require,module,exports){
var isString = require('./isString')
var isStringWithSpace = require('./isStringWithSpace')

function doubleQuoteIfStringContainsSpace (value) {
  if (isStringWithSpace(value)) {
    return '"' + value + '"'
  }

  if (isString(value)) {
    return value
  }
}

module.exports = doubleQuoteIfStringContainsSpace

},{"./isString":77,"./isStringWithSpace":80}],58:[function(require,module,exports){
function encloseWithParenthesis (value) {
  return '(' + value + ')'
}

module.exports = encloseWithParenthesis

},{}],59:[function(require,module,exports){
var isMathOperator = require('./isMathOperator')

function extractMathExpression (tokens) {
  var expression = []

  var missingRightOperand
  var token
  var nextToken

  // TODO: handle parenthesis

  // All math operators are binary.
  // Look for operators: start from second token.
  for (var i = 0; i < tokens.length - 1; i++) {
    token = tokens[i]
    nextToken = tokens[i + 1]

    if (isMathOperator(nextToken)) {
      expression.push(token, nextToken)

      i = i + 1

      missingRightOperand = true
    } else {
      if (missingRightOperand) {
        expression.push(token)
        missingRightOperand = false
        return expression
      }
    }
  }

  return expression
}

module.exports = extractMathExpression

},{"./isMathOperator":69}],60:[function(require,module,exports){
var isKeyword = require('./isKeyword')

// TODO outer, inner, full outer join, etc.

function isAnyJoin (token) {
  return (
    isKeyword('JOIN')(token) ||
    isKeyword('LEFT JOIN')(token) ||
    isKeyword('RIGHT JOIN')(token)
  )
}

module.exports = isAnyJoin

},{"./isKeyword":66}],61:[function(require,module,exports){
var error = require('../error')
var isDataType = require('./isDataType')

function isCastedValue (token) {
  var dataType = token.split('::')[1]

  if (dataType) {
    if (isDataType(dataType)) {
      return true
    } else {
      throw error.invalidDataType(dataType)
    }
  } else {
    return false
  }
}

module.exports = isCastedValue

},{"../error":1,"./isDataType":63}],62:[function(require,module,exports){
var comparisonOperators = require('./comparisonOperators.json')

function isComparisonOperator (token) {
  return comparisonOperators.indexOf(token) > -1
}

module.exports = isComparisonOperator

},{"./comparisonOperators.json":54}],63:[function(require,module,exports){
var dataTypes = require('./dataTypes.json')

function isDataType (token) {
  var TOKEN = token.toUpperCase()

  return dataTypes.indexOf(TOKEN) > -1
}

module.exports = isDataType

},{"./dataTypes.json":56}],64:[function(require,module,exports){
var isString = require('./isString')

function isDoubleQuotedString (value) {
  return isString(value) && /^"[^"]*"$/.test(value)
}

module.exports = isDoubleQuotedString

},{"./isString":77}],65:[function(require,module,exports){
var isValidName = require('./isValidName')
var isString = require('./isString')

function isFieldName (name) {
  if (!isString(name)) return false

  // A filed can be given as
  // * myfield
  // * mytable.myfield
  // * myschema.mytable.myfield
  var names = name.split('.')

  var name0 = names[0]
  var name1 = names[1]
  var name2 = names[2]

  if ((names.length === 0) || (names.length > 3)) return false

  if (names.length === 1) {
    return isValidName(name0)
  }

  if (names.length === 2) {
    return isValidName(name0) && isValidName(name1)
  }

  if (names.length === 3) {
    return isValidName(name0) && isValidName(name1) && isValidName(name2)
  }
}

module.exports = isFieldName

},{"./isString":77,"./isValidName":82}],66:[function(require,module,exports){
var keywords = require('./keywords.json')

/**
 * Tells if a token is a SQL keyword.
 *
 * There are two ways to use it.
 *
 * 1. Any keyword.
 *
 * isKeyword()('foo') => false
 * isKeyword()('count') => true
 *
 * 2. Specific keyword.
 *
 * var isCount = isKeyword('COUNT')
 * isCount('Count') => true
 * isCount('MAX') => false
 * isCount('foo') => false
 * isCount() => false
 */

function isKeyword (keyword) {
  if (keyword) {
    return function (token) {
      if (!token) return false

      var TOKEN = token.toUpperCase()

      if (keywords.indexOf(TOKEN) === -1) return false

      return keyword === TOKEN
    }
  } else {
    return function (token) {
      if (!token) return false

      var TOKEN = token.toUpperCase()

      return keywords.indexOf(TOKEN) > -1
    }
  }
}

module.exports = isKeyword

},{"./keywords.json":83}],67:[function(require,module,exports){
var comparisonOperators = require('./comparisonOperators.json')
var logicalOperators = require('./logicalOperators.json')
var mathOperators = require('./mathOperators.json')
var setOperators = require('./setOperators.json')
var stringOperators = require('./stringOperators.json')
var keywords = require('./keywords.json')

function isKeywordOrOperator (token) {
  if (comparisonOperators.indexOf(token) > -1) return true
  if (logicalOperators.indexOf(token) > -1) return true
  if (mathOperators.indexOf(token) > -1) return true
  if (setOperators.indexOf(token) > -1) return true
  if (stringOperators.indexOf(token) > -1) return true

  var TOKEN = token.toUpperCase()
  if (keywords.indexOf(TOKEN) > -1) return true

  return false
}

module.exports = isKeywordOrOperator

},{"./comparisonOperators.json":54,"./keywords.json":83,"./logicalOperators.json":84,"./mathOperators.json":85,"./setOperators.json":89,"./stringOperators.json":91}],68:[function(require,module,exports){
var logicalOperators = require('./logicalOperators.json')

function isLogicalOperator (operator) {
  return function (token) {
    var TOKEN = token.toUpperCase()

    if (logicalOperators.indexOf(TOKEN) === -1) return false

    return operator === TOKEN
  }
}

module.exports = isLogicalOperator

},{"./logicalOperators.json":84}],69:[function(require,module,exports){
var mathOperators = require('./mathOperators.json')

function isMathOperator (token) {
  return mathOperators.indexOf(token) > -1
}

module.exports = isMathOperator

},{"./mathOperators.json":85}],70:[function(require,module,exports){
function isNumber (field) {
  return typeof field === 'number'
}

module.exports = isNumber

},{}],71:[function(require,module,exports){
var isNumber = require('./isNumber')
var isString = require('./isString')

function isNumberOrString (value) {
  return isNumber(value) || isString(value)
}

module.exports = isNumberOrString

},{"./isNumber":70,"./isString":77}],72:[function(require,module,exports){
function isObject (field) {
  return typeof field === 'object'
}

module.exports = isObject

},{}],73:[function(require,module,exports){
var partialKeywords = require('./partialKeywords.json')

function isPartialKeyword (token) {
  var TOKEN = token.toUpperCase()

  return partialKeywords.indexOf(TOKEN) > -1
}

module.exports = isPartialKeyword

},{"./partialKeywords.json":86}],74:[function(require,module,exports){
var isKeyword = require('./isKeyword')

var isExcept = isKeyword('EXCEPT')
var isIntersect = isKeyword('INTERSECT')
var isUnion = isKeyword('UNION')
var isUnionAll = isKeyword('UNION ALL')

function isSetOperator (token) {
  return (isExcept(token) || isIntersect(token) || isUnion(token) || isUnionAll(token))
}

module.exports = isSetOperator

},{"./isKeyword":66}],75:[function(require,module,exports){
var isString = require('./isString')

function isSingleQuotedString (value) {
  return isString(value) && /^'[^']*'$/.test(value)
}

module.exports = isSingleQuotedString

},{"./isString":77}],76:[function(require,module,exports){
function isStar (field) {
  return field === '*'
}

module.exports = isStar

},{}],77:[function(require,module,exports){
var isStar = require('./isStar')

function isString (value) {
  if (typeof value === 'string') {
    return (['(', ',', ')'].indexOf(value) === -1) && (!isStar(value))
  } else {
    return false
  }
}

module.exports = isString

},{"./isStar":76}],78:[function(require,module,exports){
var isCastedValue = require('./isCastedValue')

function isStringNumber (value) {
  // Handle values like 1::VARCHAR which could be parsed as 1 by parseFloat.
  if (isCastedValue(value)) return false

  return !isNaN(parseFloat(value))
}

module.exports = isStringNumber

},{"./isCastedValue":61}],79:[function(require,module,exports){
var stringOperators = require('./stringOperators.json')

function isStringOperator (token) {
  return stringOperators.indexOf(token) > -1
}

module.exports = isStringOperator

},{"./stringOperators.json":91}],80:[function(require,module,exports){
var isString = require('./isString')

function isStringWithSpace (value) {
  return isString(value) && /\s/.test(value)
}

module.exports = isStringWithSpace

},{"./isString":77}],81:[function(require,module,exports){
var isKeyword = require('./isKeyword')
var isString = require('./isString')
var isValidName = require('./isValidName')

function isTableName (token) {
  if (!isString(token)) return false

  if (isKeyword()(token)) return false

  // A table can be given as
  //
  // * mytable
  // * myschema.mytable
  //
  var names = token.split('.')

  if ((names.length === 0) || (names.length > 2)) return false

  if (names.length === 1) {
    return isValidName(names[0])
  }

  if (names.length === 2) {
    return isValidName(names[0]) && isValidName(names[1])
  }
}

module.exports = isTableName

},{"./isKeyword":66,"./isString":77,"./isValidName":82}],82:[function(require,module,exports){
var isString = require('./isString')

function isValidName (name) {
  if (!isString(name)) return false

  return /^[a-zA-Z_][a-zA-Z_0-9]*$/.test(name)
}

module.exports = isValidName

},{"./isString":77}],83:[function(require,module,exports){
module.exports=[
  "AS",
  "ASC",
  "AVG",
  "BETWEEN",
  "CASE",
  "COALESCE",
  "COUNT",
  "CREATE DATABASE",
  "CREATE SCHEMA",
  "CREATE SEQUENCE",
  "CREATE TABLE",
  "CREATE USER",
  "CREATE VIEW",
  "DATABASE",
  "DELETE FROM",
  "DESC",
  "DISTINCT",
  "DROP",
  "DROP TABLE",
  "END",
  "EXCEPT",
  "EXISTS",
  "EXPLAIN",
  "FALSE",
  "FROM",
  "FULL OUTER JOIN",
  "GRANT",
  "GROUP BY",
  "JOIN",
  "HAVING",
  "IN",
  "INNER JOIN",
  "INSERT",
  "INTERSECT",
  "IS",
  "IS FALSE",
  "IS NOT FALSE",
  "IS NOT NULL",
  "IS NOT TRUE",
  "IS NULL",
  "IS TRUE",
  "LIMIT",
  "LIKE",
  "LEFT JOIN",
  "LEFT OUTER JOIN",
  "LOWER",
  "MAX",
  "MIN",
  "ORDER BY",
  "OUTER JOIN",
  "NOT BETWEEN",
  "NOT EXISTS",
  "NOT LIKE",
  "NULL",
  "NVL",
  "OFFSET",
  "ON",
  "RIGHT JOIN",
  "SELECT",
  "SET",
  "SUM",
  "TABLE",
  "TRUE",
  "UNION",
  "UNION ALL",
  "UPDATE",
  "UPPER",
  "USER",
  "VALUES",
  "VIEW",
  "WHERE",
  "WITH"
]

},{}],84:[function(require,module,exports){
module.exports=["AND", "OR"]

},{}],85:[function(require,module,exports){
module.exports=[ "+", "-", "*", "/", "%" ]

},{}],86:[function(require,module,exports){
module.exports=[
  "CREATE",
  "CROSS",
  "DELETE",
  "DROP",
  "FULL",
  "GROUP",
  "INNER",
  "IS",
  "LEFT",
  "NOT",
  "ORDER",
  "RIGHT",
  "UNION"
]

},{}],87:[function(require,module,exports){
function quoteIfString (value) {
  if (typeof value === 'string') return "'" + value + "'"
  else return value
}

module.exports = quoteIfString

},{}],88:[function(require,module,exports){
function removeFirstAndLastChar (token) {
  return token.substring(1, token.length - 1)
}

module.exports = removeFirstAndLastChar

},{}],89:[function(require,module,exports){
module.exports=[
  "EXCEPT",
  "INTERSECT",
  "UNION",
  "UNION ALL"
]

},{}],90:[function(require,module,exports){
var comparisonOperators = require('./comparisonOperators.json')

/**
 * Take a string that is supposed to be not quoted or double quoted.
 * Split it on any operator: comma, parenthesis, comparison operators, etc.
 * Furthermore, content is trimmed and splitted on comma or spaces.
 *
 * 'COUNT(*)' => ['COUNT', '(', '*', ')']
 * 'COUNT( 1   )' => ['COUNT', '(', '1', ')']
 * 'COUNT( DISTINCT cities )' => ['COUNT', '(', 'DISTINCT', 'cities', ')']
 * 'yyyymmdd=20170101' => ['yyyymmdd', '=', '20170101']
 *
 * @param {String} notQuotedString
 *
 * @return {Array} tokens
 */

var semiOperators = ['>', '<', '!']

var otherOperators = ['(', ')', ',', ';']

var operators = comparisonOperators.concat(otherOperators)

function splitOnOperators (notQuotedString) {
  var tokens = []

  function blanks (x) { return x !== '' }

  notQuotedString.trim().split(' ').filter(blanks).forEach(function (word) {
    var currentToken = ''
    var numCharacters = word.length

    for (var i = 0; i < numCharacters; i++) {
      var character = word[i]

      var isLastCharacter = i === numCharacters - 1

      var characterIsOperator = operators.indexOf(character) > -1
      var characterIsSemiOperator = semiOperators.indexOf(character) > -1

      var nextCharacter

      if (characterIsSemiOperator && (!isLastCharacter)) {
        nextCharacter = word[i + 1]

        var maybeOperator = character + nextCharacter

        var actuallyItIsOperator = operators.indexOf(maybeOperator) > -1

        if (actuallyItIsOperator) {
          if (currentToken !== '') tokens.push(currentToken)

          tokens.push(maybeOperator)

          currentToken = ''

          i = i + 1

          continue
        }
      }

      if (characterIsOperator) {
        if (currentToken !== '') tokens.push(currentToken)

        tokens.push(character)

        currentToken = ''
      } else {
        currentToken += character

        if (isLastCharacter) tokens.push(currentToken)
      }
    }
  })

  return tokens
}

module.exports = splitOnOperators

},{"./comparisonOperators.json":54}],91:[function(require,module,exports){
module.exports=[ "||" ]

},{}],92:[function(require,module,exports){
var splitOnOperators = require('./splitOnOperators')
var isPartialKeyword = require('./isPartialKeyword')

var isKeyword = require('../util/isKeyword')
var isIn = isKeyword('IN')

/**
r* Analyze SQL and convert it into a list of tokens.
 *
 * @param {String} sql
 *
 * @returns {Array} tokens
 */

function tokenize (sql) {
  var tokens = []

  // Trim and analyze single quotes first. They are special characters in SQL.

  // No SQL statement can start with a quoted word.
  var isQuoted = false
  var currentQuotedValue = ''

  sql.trim().split("'").forEach(function (currentValue, index, array) {
    var nextValue

    if (isQuoted) {
      // Concatenate currentValue with currentQuotedValue, if any, cause
      // previous value could be quoted as well.
      if (currentQuotedValue === '') {
        currentQuotedValue = currentValue
      } else {
        currentQuotedValue += "'" + currentValue
      }

      // Return if it is last element, otherwise nextValue will be undefined.
      if (index === array.length - 1) {
        tokens.push("'" + currentQuotedValue)

        return
      } else {
        // A single quote can be escaped by another single quote.
        //
        // > var sql = "select 'O''Reilly';"
        // > sql.split(/'/)
        // [ 'select ', 'O', '', 'Reilly', ';' ]

        nextValue = array[index + 1]

        // If currentValue is quoted and two consecutive single quotes are found,
        // return to avoid toggling the isQuoted flag, hence nextValue will
        // be considered quoted and concatenated to currentQuotedValue.
        //
        // Otherwise just push the quoted token found.
        if (nextValue === '') {
          return
        } else {
          tokens.push("'" + currentQuotedValue + "'")
        }
      }
    } else {
      // Reset currentQuotedValue for next iteration
      currentQuotedValue = ''

      // Now let's care about double quotes, they are valid outside single
      // quotes and can concatenate more words into one token, for example
      //
      // select 1 as "number one";

      var currentToken = ''

      // The currentToken, after trimmed, could start with a double quote
      //
      // select 'select' "select"

      currentValue = currentValue.trim()
      var isDoubleQuoted = currentValue[0] === '"'

      currentValue.split('').forEach(function (currentChar, index, array) {
        // Special characters are considered as a space.
        var isEquivalentToSpace = (
          (currentChar === '\n') ||
          (currentChar === '\r') ||
          (currentChar === '\t')
        )

        if ((currentChar === ' ') || isEquivalentToSpace) {
          if (isDoubleQuoted) {
            currentToken += ' '
          } else {
            if (currentToken !== '') {
              // Close current token, only if it is valued otherwise many
              // equivalent to space characters concatenated will produce
              // empty tokens.
              tokens = tokens.concat(splitOnOperators(currentToken))

              currentToken = ''
            }
          }
        } else {
          if (currentChar === '"') {
            if (isDoubleQuoted) {
              // Close current double quoted token.
              isDoubleQuoted = false
              tokens.push(currentToken + '"')
              currentToken = ''
            } else {
              // Start a new double quoted token.
              isDoubleQuoted = true
              currentToken = '"'
            }
          } else {
            currentToken += currentChar

            // Push it, if it is last token.
            if (index === array.length - 1) {
              tokens = tokens.concat(splitOnOperators(currentToken))
            }
          }
        }
      })
    }

    // Toggle the isQuoted flag:
    // if currentValue is quoted the next one will not, and viceversa.
    isQuoted = !isQuoted
  })

  // Finally, we have all tokens but some keywords are composed by two or
  // more words, for example "GROUP BY", "LEFT OUTER JOIN"

  var joinedTokens = []
  var numTokens = tokens.length

  for (var i = 0; i < numTokens; i++) {
    var token = tokens[i]

    var isNotLastToken = i < numTokens - 1
    var nextToken
    var NEXT_TOKEN

    if (isNotLastToken) {
      nextToken = tokens[i + 1]
      NEXT_TOKEN = nextToken.toUpperCase()
    }

    var isNotSecondToLastToken = i < numTokens - 2
    var afterNextToken
    var AFTER_NEXT_TOKEN

    if (isNotSecondToLastToken) {
      afterNextToken = tokens[i + 2]
      AFTER_NEXT_TOKEN = afterNextToken.toUpperCase()
    }

    if (isPartialKeyword(token)) {
      var TOKEN = token.toUpperCase()

      if ((TOKEN === 'CREATE') || (TOKEN === 'DROP')) {
        if ([
          'DATABASE', 'SCHEMA', 'SEQUENCE',
          'TABLE', 'USER', 'VIEW'
        ].indexOf(NEXT_TOKEN) > -1) {
          joinedTokens.push(token + ' ' + nextToken)
          i = i + 1
        }
      }

      if (TOKEN === 'DELETE') {
        if (NEXT_TOKEN === 'FROM') {
          joinedTokens.push(token + ' ' + nextToken)
          i = i + 1
        }
      }

      if ((TOKEN === 'GROUP') || (TOKEN === 'ORDER')) {
        if (NEXT_TOKEN === 'BY') {
          joinedTokens.push(token + ' ' + nextToken)
          i = i + 1
        }
      }

      if ((TOKEN === 'LEFT') || (TOKEN === 'RIGHT')) {
        if ((NEXT_TOKEN === 'OUTER') && (AFTER_NEXT_TOKEN === 'JOIN')) {
          joinedTokens.push(token + ' ' + nextToken + ' ' + afterNextToken)
          i = i + 2
        }

        if (NEXT_TOKEN === 'JOIN') {
          joinedTokens.push(token + ' ' + nextToken)
          i = i + 1
        }
      }

      if ((TOKEN === 'INNER') || (TOKEN === 'CROSS')) {
        if (NEXT_TOKEN === 'JOIN') {
          joinedTokens.push(token + ' ' + nextToken)
          i = i + 1
        }
      }

      if ((TOKEN === 'FULL') && (NEXT_TOKEN === 'OUTER') && (AFTER_NEXT_TOKEN === 'JOIN')) {
        joinedTokens.push(token + ' ' + nextToken + ' ' + afterNextToken)
        i = i + 2
      }

      if (TOKEN === 'UNION') {
        if (NEXT_TOKEN === 'ALL') {
          joinedTokens.push(token + ' ' + nextToken)
          i = i + 1
        } else {
          joinedTokens.push(token)
        }
      }

      if (TOKEN === 'NOT') {
        if ((NEXT_TOKEN === 'LIKE') || (NEXT_TOKEN === 'BETWEEN')) {
          joinedTokens.push(token + ' ' + nextToken)
          i = i + 1
        }
      }
    } else {
      // FIXME
      if (isIn(token)) {
        joinedTokens.push('IN')
      } else {
        joinedTokens.push(token)
      }
    }
  }

  return joinedTokens
}

module.exports = tokenize

},{"../util/isKeyword":66,"./isPartialKeyword":73,"./splitOnOperators":90}],93:[function(require,module,exports){
var error = require('../error')

/**
 * Extract a set of tokens enclosed by parenthesis
 *
 * ['(', 'a',  ')', 'bla bla'] => ['(', 'a',  ')']
 * ['xxx', '(', 'COUNT', '(', '*', ')', ')', 'xxx'] => ['(', 'COUNT', '(', '*', ')'  ')']
 *
 * @param {Array} tokens
 * @param {Number} startIndex
 *
 * @returns {Array} enclosedTokens
 */

function tokenEnclosedByParenthesis (tokens, startIndex) {
  var numTokens = tokens.length
  var enclosedTokens = []
  var foundLeftParenthesis = false
  var foundRightParenthesis = false
  var numOpenParenthesis = 0
  var token

  for (var i = startIndex; i < numTokens; i++) {
    token = tokens[i]

    if (token === '(') numOpenParenthesis++
    if (token === ')') numOpenParenthesis--

    if ((token === '(') && (numOpenParenthesis === 1)) {
      foundLeftParenthesis = true
    }

    // Nothing todo if left parenthesis was not found yet.
    if (!foundLeftParenthesis) continue

    enclosedTokens.push(token)

    if ((token === ')') && (numOpenParenthesis === 0)) {
      foundRightParenthesis = true
      break
    }
  }

  if (!foundRightParenthesis && foundLeftParenthesis) {
    throw error.unclosedParenthesisExpression(tokens)
  }

  return enclosedTokens
}

module.exports = tokenEnclosedByParenthesis

},{"../error":1}],"sql92-json":[function(require,module,exports){
module.exports = exports.default = {
  parse: require('./parse'),
  stringify: require('./stringify')
}

},{"./parse":8,"./stringify":35}]},{},[]);
